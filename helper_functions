#In this module, we will define a function capable of generating Poisson hyperplane tessellations in arbitrary dimensions,
#and then color those tesselations I.I.D. with a random color.

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import scipy.special as sp
from matplotlib.patches import Circle
import matplotlib.colors as mcolors
from numba import jit
from collections import defaultdict
from scipy.spatial import ConvexHull
from shapely.geometry import Polygon, LineString
from itertools import combinations
import itertools
import math
from functools import lru_cache
import pickle
import hashlib


####### helper functions and 2d color plots #######
def rate(d, r):
    """Calculates the arrival rate of a rigid-motion invariant Poisson hyperplane process in d dimensions
    such that the arrival rate of hyperplanes hitting a line segment is independant of dimension.
    
    d: int, the dimension of the space
    r: float, the radius of the enveloping ball of the Poisson hyperplane process
       
    returns: float, the rate of the Poisson hyperplane process
    >>> rate(1, 1)
    2
    >>> rate(2, 1)  # doctest: +ELLIPSIS
    3.14...
    >>> rate(3, 1)  # doctest: +ELLIPSIS
    4.0...
    """
    
    if d == 1: #the formula won't work for d=1
        return 2*r
    else: #rate is 2r/lambda_d from the paper
        return 2*np.sqrt(np.pi) * sp.gamma(d/2 + 1/2) / sp.gamma(d/2) * r
    

def sample_from_ball(d, n):
    """ Sample n points from interior of unit d-ball by uniformly sampling angle and then offset

    d: int, the dimension of the space
    n: int, the number of points to sample
    returns: np.array, shape (n, d), the sampled points

    """
    points = np.random.normal(size=(n, d))
    scales = np.random.uniform(size=(n, 1))
    norms = np.linalg.norm(points, axis=1, keepdims=True)
    unit_ball_points = points / norms * scales
    return unit_ball_points

@jit(nopython=True)
def hyperplane_partition(points, gridpoints):
    """Returns a unique hash for each grid point for unlimited number of hyperplanes
    
    points: np.array, shape (n,d), the points defining the hyperplanes
    gridpoints: np.array, shape (N,d), the points at which to evaluate the hyperplanes

    returns: np.array, the region hashes for the gridpoints
    """
    num_hyperplanes = points.shape[0]
    num_regions = gridpoints.shape[0]
    region_hashes = np.zeros((num_regions, (num_hyperplanes + 63) // 64), dtype=np.int64)
    #region hashes assigns each gridpoint to a region based on the hyperplanes
    #each set of 64 hyperplanes forms a bitwise hash map for each gridpoint
    for i, point in enumerate(points):
        gridpoints_cont = np.ascontiguousarray(gridpoints - point)
        point_cont = np.ascontiguousarray(point)
        signs = np.sign(np.dot(gridpoints_cont, point_cont)).astype(np.int8)
        bucket, offset = divmod(i, 64)
        region_hashes[:, bucket] += (signs > 0).astype(np.int64) << offset
    
    return region_hashes

def _hash_tuple_to_unit_interval(tup, salt=0):
    """Deterministic float in [0,1) from an integer tuple."""
    m = hashlib.blake2b(digest_size=8)
    m.update(np.array([salt], dtype=np.int64).tobytes())
    m.update(np.array(tup, dtype=np.int64).tobytes())
    val = int.from_bytes(m.digest(), 'little')
    return (val & ((1 << 53) - 1)) / float(1 << 53)  # map to [0,1)

def hyperplane_colorer_2D(points, gridpoints, colorcutoffs, salt=12345):
    """
    Returns color indices for a 2D ball partitioned by hyperplanes.
    Color is deterministic per-region using a hash of the region's bit-signature,
    so changing N (grid resolution) won't reshuffle colors.
    """
    region_hashes = hyperplane_partition(points, gridpoints)

    # Convert per-point multi-int signatures to tuples (hashable)
    region_hashes_tuples = [tuple(row) for row in region_hashes]

    # Build a stable mapping: region tuple -> color index
    color_lookup = {}
    def color_index_for_region(t):
        if t not in color_lookup:
            u = _hash_tuple_to_unit_interval(t, salt=salt)   # deterministic in [0,1)
            color_lookup[t] = np.digitize(u, colorcutoffs)   # 0..len(colorcutoffs)
        return color_lookup[t]

    regions = np.fromiter(
        (color_index_for_region(t) for t in region_hashes_tuples),
        dtype=np.int32,
        count=len(region_hashes_tuples)
    )
    return regions


def plot_hyperplanes_color_2D(r, N=100, colorcutoffs=np.array([0.5]),  figsize = (6,6), preview_dpi=100):
    """
    Plots the Poisson hyperplane process in a ball in 2D, colored by region.
    
    r: float, The radius of the enveloping ball of the Poisson hyperplane process
    N: int, the number of points in the grid in each direction (default 100)
    colorcutoffs: np.array, the cutoffs for the colors (default np.array([0.5]))
    resolution: int, the resolution of the grid used to identify unique regions (default 100)

    returns: figure, the figure object
    """
    if len(colorcutoffs) > 10:
        print("Too many colors, please choose 10 or fewer")
        return

    d = 2
    n = np.random.poisson(rate(d, r))
    points = sample_from_ball(d, n) * r

    x = np.linspace(-r, r, N)
    y = np.linspace(-r, r, N)
    xx, yy = np.meshgrid(x, y)
    gridpoints = np.c_[xx.ravel(), yy.ravel()]

    # Use the updated safe colorer
    values = hyperplane_colorer_2D(points, gridpoints, colorcutoffs).reshape(N, N)

    fig, ax = plt.subplots(figsize = figsize, dpi=preview_dpi)
    #the first set of colors is for fig. 1.a., the second set is for fig. 1.b.
    #cmap = mcolors.ListedColormap(['#d22c2c', '#f4d5ce', 'green', 'purple', 'orange', 'yellow', 'pink', 'cyan', 'magenta', 'navy'])
    cmap = mcolors.ListedColormap(['#043765', "#edf8fe", 'green', 'purple', 'orange', 'yellow', 'pink', 'cyan', 'magenta', 'navy'])
    bounds = np.linspace(-0.5, len(cmap.colors) - 0.5, len(cmap.colors) + 1)
    norm = mcolors.BoundaryNorm(bounds, cmap.N)

    cax = ax.imshow(values, extent=(-r, r, -r, r), origin='lower', cmap=cmap, norm=norm, interpolation='nearest', resample=False)

    # Create a circular clip path
    clip_circle = Circle((0, 0), r, transform=ax.transData)
    for artist in ax.get_children():
        artist.set_clip_path(clip_circle)
    ax.set_aspect('equal')
    ax.axis('off')
    plt.show()

    return fig

if __name__ == "__main__":
    import os 
    res = 300
    rad = 20
    cutoff = .65

    fig1 = plot_hyperplanes_color_2D(rad, res, colorcutoffs=np.array([cutoff]))
